Total: 165 samples
     120  72.7%  72.7%      165 100.0% wrapper
      30  18.2%  90.9%       30  18.2% SortedList_insert
      15   9.1% 100.0%       15   9.1% SortedList_lookup
       0   0.0% 100.0%      165 100.0% __clone
       0   0.0% 100.0%      165 100.0% start_thread
ROUTINE ====================== wrapper in /u/eng/class/classdle/cs111/project2b/lab2_list.c
   120    165 Total samples (flat / cumulative)
     .      .   39: }
     .      .   40: 
     .      .   41: pthread_mutex_t *mutexlock;
     .      .   42: volatile int *spinlock;
     .      .   43: void *wrapper(void* startVoid)
---
     .      .   44: {
     .      .   45:   if (errorThrown != 0)//If on thread calls errorMessage, everyone exit
     .      .   46:     exit(errorThrown);
     .      .   47:   int start = * (int *)startVoid;
     .      .   48:   int end = numIters + start;
     .      .   49:   int timeIndex = start / numIters; //Use time index as list key
     .      .   50:   int listKey = (start / numIters) % numList;
     .      .   51:   if (syncCh == 's')
     .      .   52:     {
     .      .   53:       //       while (__sync_lock_test_and_set(&spinlock, 1)) {};
     .      .   54:       int i = start;
     .      .   55: 
     .      .   56:       for (; i < end; i++)
     .      .   57: 	{
    82     82   58: 	  while (__sync_lock_test_and_set(&spinlock[listKey], 1)) {};      
     .     30   59: 	  SortedList_insert(&headElement[listKey], &elementArray[i]);
     .      .   60: 	  if (headElement[listKey].key != NULL)
     .      .   61: 	    errorMessage("There was a problem with insertion", 2);
     .      .   62: 	  __sync_lock_release(&spinlock[listKey]);
     .      .   63: 	}
     .      .   64: 
     .      .   65:       while (__sync_lock_test_and_set(&spinlock[listKey], 1)) {};
     .      .   66:       if (SortedList_length(&headElement[listKey]) == -1)
     .      .   67: 	errorMessage("There was an inconsistency when getting length", 2);
     .      .   68:       __sync_lock_release(&spinlock[listKey]);
     .      .   69: 
     .      .   70: 
     .      .   71:       for (i = start; i < end; i++)
     .      .   72: 	{
    38     38   73: 	  while (__sync_lock_test_and_set(&spinlock[listKey], 1)) {};
     .     15   74: 	  SortedList_t * temp = SortedList_lookup(&headElement[listKey], elementArray[i].key);
     .      .   75: 	  if (temp == NULL)
     .      .   76: 	    errorMessage("There was an inconsistency when looking up", 2);
     .      .   77: 	  if (SortedList_delete(temp) == 1)
     .      .   78: 	    errorMessage("There was an inconsistency when deleting", 2);
     .      .   79: 	  __sync_lock_release(&spinlock[listKey]);
     .      .   80: 	}
     .      .   81:       
     .      .   82: 
     .      .   83:       //              __sync_lock_release(&spinlock);
     .      .   84:     }
     .      .   85:   else if (syncCh == 'm')
     .      .   86:     {
     .      .   87:       //      pthread_mutex_lock(&lock);
     .      .   88:       struct timespec begin;
     .      .   89:       struct timespec finish;
     .      .   90:       long long runtime;
     .      .   91:       int i = start;
     .      .   92:       for (; i < end; i++)
     .      .   93: 	{
     .      .   94: 	  clock_gettime(CLOCK_MONOTONIC, &begin);
     .      .   95: 	  pthread_mutex_lock(&mutexlock[listKey]);
     .      .   96: 	  clock_gettime(CLOCK_MONOTONIC, &finish);
     .      .   97: 	    runtime = ((1000000000* finish.tv_sec) + finish.tv_nsec) - ((1000000000* begin.tv_sec) + begin.tv_nsec);
     .      .   98: 	    timeArray[timeIndex] += runtime;
     .      .   99: 	  SortedList_insert(&headElement[listKey], &elementArray[i]);
     .      .  100: 	  if (headElement[listKey].key != NULL)
     .      .  101: 	    errorMessage("There was a problem with insertion", 2);
     .      .  102: 	  pthread_mutex_unlock(&mutexlock[listKey]);      
     .      .  103: 	}
     .      .  104:       
     .      .  105:       clock_gettime(CLOCK_MONOTONIC, &begin);
     .      .  106:       pthread_mutex_lock(&mutexlock[listKey]);
     .      .  107:       clock_gettime(CLOCK_MONOTONIC, &finish);
     .      .  108:       runtime = ((1000000000* finish.tv_sec) + finish.tv_nsec) - ((1000000000* begin.tv_sec) + begin.tv_nsec);
     .      .  109:       timeArray[timeIndex] += runtime;
     .      .  110:       if (SortedList_length(&headElement[listKey]) == -1)
     .      .  111: 	errorMessage("There was an inconsistency when getting length", 2);
     .      .  112:       pthread_mutex_unlock(&mutexlock[listKey]);
     .      .  113: 
     .      .  114: 
     .      .  115:       for (i = start; i < end; i++)
     .      .  116: 	{
     .      .  117: 
     .      .  118: 	  clock_gettime(CLOCK_MONOTONIC, &begin);
     .      .  119: 	  pthread_mutex_lock(&mutexlock[listKey]);
     .      .  120: 	  clock_gettime(CLOCK_MONOTONIC, &finish);
     .      .  121: 	  runtime = ((1000000000* finish.tv_sec) + finish.tv_nsec) - ((1000000000* begin.tv_sec) + begin.tv_nsec);
     .      .  122: 	  timeArray[timeIndex] += runtime;
     .      .  123: 	  SortedList_t * temp = SortedList_lookup(&headElement[listKey], elementArray[i].key);
     .      .  124: 	  if (temp == NULL)
     .      .  125: 	    errorMessage("There was an inconsistency when looking up", 2);
     .      .  126: 	  if (SortedList_delete(temp) == 1)
     .      .  127: 	    errorMessage("There was an inconsistency when deleting", 2);
     .      .  128: 	  pthread_mutex_unlock(&mutexlock[listKey]);
     .      .  129: 	}
     .      .  130:       
     .      .  131:       // pthread_mutex_unlock(&lock);
     .      .  132:     }
     .      .  133:   else
     .      .  134:     {
     .      .  135: 	  int i = start;
     .      .  136: 	  for (; i < end; i++)
     .      .  137: 	    {
     .      .  138: 	      SortedList_insert(&headElement[listKey], &elementArray[i]);
     .      .  139: 	      if (headElement[listKey].key != NULL)
     .      .  140: 		errorMessage("There was a problem with insertion", 2);
     .      .  141: 	    }
     .      .  142: 	  if (SortedList_length(&headElement[listKey]) == -1)
     .      .  143: 	    errorMessage("There was an inconsistency when getting length", 2);
     .      .  144: 	  for (i = start; i < end; i++)
     .      .  145: 	    {
     .      .  146: 	      SortedList_t * temp = SortedList_lookup(&headElement[listKey], elementArray[i].key);
     .      .  147: 	      if (temp == NULL)
     .      .  148: 		errorMessage("There was an inconsistency when looking up", 2);
     .      .  149: 	      if (SortedList_delete(temp) == 1)
     .      .  150: 		errorMessage("There was an inconsistency when deleting", 2);
     .      .  151: 	    }
     .      .  152:     }    
     .      .  153:   return NULL;
     .      .  154: }
---
     .      .  155: void random_key(SortedListElement_t *element)
     .      .  156: {
     .      .  157:   char charset[] = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
     .      .  158:   char *temp = malloc(length * sizeof(char));
     .      .  159:   if (temp == NULL)
ROUTINE ====================== wrapper in /u/eng/class/classdle/cs111/project2b/lab2_list.c
   120    165 Total samples (flat / cumulative)
     .      .   39: }
     .      .   40: 
     .      .   41: pthread_mutex_t *mutexlock;
     .      .   42: volatile int *spinlock;
     .      .   43: void *wrapper(void* startVoid)
---
     .      .   44: {
     .      .   45:   if (errorThrown != 0)//If on thread calls errorMessage, everyone exit
     .      .   46:     exit(errorThrown);
     .      .   47:   int start = * (int *)startVoid;
     .      .   48:   int end = numIters + start;
     .      .   49:   int timeIndex = start / numIters; //Use time index as list key
     .      .   50:   int listKey = (start / numIters) % numList;
     .      .   51:   if (syncCh == 's')
     .      .   52:     {
     .      .   53:       //       while (__sync_lock_test_and_set(&spinlock, 1)) {};
     .      .   54:       int i = start;
     .      .   55: 
     .      .   56:       for (; i < end; i++)
     .      .   57: 	{
    82     82   58: 	  while (__sync_lock_test_and_set(&spinlock[listKey], 1)) {};      
     .     30   59: 	  SortedList_insert(&headElement[listKey], &elementArray[i]);
     .      .   60: 	  if (headElement[listKey].key != NULL)
     .      .   61: 	    errorMessage("There was a problem with insertion", 2);
     .      .   62: 	  __sync_lock_release(&spinlock[listKey]);
     .      .   63: 	}
     .      .   64: 
     .      .   65:       while (__sync_lock_test_and_set(&spinlock[listKey], 1)) {};
     .      .   66:       if (SortedList_length(&headElement[listKey]) == -1)
     .      .   67: 	errorMessage("There was an inconsistency when getting length", 2);
     .      .   68:       __sync_lock_release(&spinlock[listKey]);
     .      .   69: 
     .      .   70: 
     .      .   71:       for (i = start; i < end; i++)
     .      .   72: 	{
    38     38   73: 	  while (__sync_lock_test_and_set(&spinlock[listKey], 1)) {};
     .     15   74: 	  SortedList_t * temp = SortedList_lookup(&headElement[listKey], elementArray[i].key);
     .      .   75: 	  if (temp == NULL)
     .      .   76: 	    errorMessage("There was an inconsistency when looking up", 2);
     .      .   77: 	  if (SortedList_delete(temp) == 1)
     .      .   78: 	    errorMessage("There was an inconsistency when deleting", 2);
     .      .   79: 	  __sync_lock_release(&spinlock[listKey]);
     .      .   80: 	}
     .      .   81:       
     .      .   82: 
     .      .   83:       //              __sync_lock_release(&spinlock);
     .      .   84:     }
     .      .   85:   else if (syncCh == 'm')
     .      .   86:     {
     .      .   87:       //      pthread_mutex_lock(&lock);
     .      .   88:       struct timespec begin;
     .      .   89:       struct timespec finish;
     .      .   90:       long long runtime;
     .      .   91:       int i = start;
     .      .   92:       for (; i < end; i++)
     .      .   93: 	{
     .      .   94: 	  clock_gettime(CLOCK_MONOTONIC, &begin);
     .      .   95: 	  pthread_mutex_lock(&mutexlock[listKey]);
     .      .   96: 	  clock_gettime(CLOCK_MONOTONIC, &finish);
     .      .   97: 	    runtime = ((1000000000* finish.tv_sec) + finish.tv_nsec) - ((1000000000* begin.tv_sec) + begin.tv_nsec);
     .      .   98: 	    timeArray[timeIndex] += runtime;
     .      .   99: 	  SortedList_insert(&headElement[listKey], &elementArray[i]);
     .      .  100: 	  if (headElement[listKey].key != NULL)
     .      .  101: 	    errorMessage("There was a problem with insertion", 2);
     .      .  102: 	  pthread_mutex_unlock(&mutexlock[listKey]);      
     .      .  103: 	}
     .      .  104:       
     .      .  105:       clock_gettime(CLOCK_MONOTONIC, &begin);
     .      .  106:       pthread_mutex_lock(&mutexlock[listKey]);
     .      .  107:       clock_gettime(CLOCK_MONOTONIC, &finish);
     .      .  108:       runtime = ((1000000000* finish.tv_sec) + finish.tv_nsec) - ((1000000000* begin.tv_sec) + begin.tv_nsec);
     .      .  109:       timeArray[timeIndex] += runtime;
     .      .  110:       if (SortedList_length(&headElement[listKey]) == -1)
     .      .  111: 	errorMessage("There was an inconsistency when getting length", 2);
     .      .  112:       pthread_mutex_unlock(&mutexlock[listKey]);
     .      .  113: 
     .      .  114: 
     .      .  115:       for (i = start; i < end; i++)
     .      .  116: 	{
     .      .  117: 
     .      .  118: 	  clock_gettime(CLOCK_MONOTONIC, &begin);
     .      .  119: 	  pthread_mutex_lock(&mutexlock[listKey]);
     .      .  120: 	  clock_gettime(CLOCK_MONOTONIC, &finish);
     .      .  121: 	  runtime = ((1000000000* finish.tv_sec) + finish.tv_nsec) - ((1000000000* begin.tv_sec) + begin.tv_nsec);
     .      .  122: 	  timeArray[timeIndex] += runtime;
     .      .  123: 	  SortedList_t * temp = SortedList_lookup(&headElement[listKey], elementArray[i].key);
     .      .  124: 	  if (temp == NULL)
     .      .  125: 	    errorMessage("There was an inconsistency when looking up", 2);
     .      .  126: 	  if (SortedList_delete(temp) == 1)
     .      .  127: 	    errorMessage("There was an inconsistency when deleting", 2);
     .      .  128: 	  pthread_mutex_unlock(&mutexlock[listKey]);
     .      .  129: 	}
     .      .  130:       
     .      .  131:       // pthread_mutex_unlock(&lock);
     .      .  132:     }
     .      .  133:   else
     .      .  134:     {
     .      .  135: 	  int i = start;
     .      .  136: 	  for (; i < end; i++)
     .      .  137: 	    {
     .      .  138: 	      SortedList_insert(&headElement[listKey], &elementArray[i]);
     .      .  139: 	      if (headElement[listKey].key != NULL)
     .      .  140: 		errorMessage("There was a problem with insertion", 2);
     .      .  141: 	    }
     .      .  142: 	  if (SortedList_length(&headElement[listKey]) == -1)
     .      .  143: 	    errorMessage("There was an inconsistency when getting length", 2);
     .      .  144: 	  for (i = start; i < end; i++)
     .      .  145: 	    {
     .      .  146: 	      SortedList_t * temp = SortedList_lookup(&headElement[listKey], elementArray[i].key);
     .      .  147: 	      if (temp == NULL)
     .      .  148: 		errorMessage("There was an inconsistency when looking up", 2);
     .      .  149: 	      if (SortedList_delete(temp) == 1)
     .      .  150: 		errorMessage("There was an inconsistency when deleting", 2);
     .      .  151: 	    }
     .      .  152:     }    
     .      .  153:   return NULL;
     .      .  154: }
---
     .      .  155: void random_key(SortedListElement_t *element)
     .      .  156: {
     .      .  157:   char charset[] = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
     .      .  158:   char *temp = malloc(length * sizeof(char));
     .      .  159:   if (temp == NULL)
